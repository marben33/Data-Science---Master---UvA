---
title: "BDST_DV_ASS_3_FINAL"
author: "Bence Andr√°s Marosi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Libraries
```{r}
library(tidyverse)
library(ggplot2)
library(cowplot)
library(dplyr)
library(mirt)
library(DescTools)
```

# Connecting to the server
```{r}
con <- oefenwebDatabase::connect()
```

# Data Preprocessing
#### Reading logrecords for items
```{r}
logrecords1 <- DBI::dbGetQuery(con,
                               "SELECT *
                               FROM log_records_1")

logrecords15 <- DBI::dbGetQuery(con,
                                "SELECT *
                               FROM log_records_15")
logrecords16 <- DBI::dbGetQuery(con,
                                "SELECT *
                               FROM log_records_16")
logrecords2 <- DBI::dbGetQuery(con,
                               "SELECT *
                               FROM log_records_2")
logrecords3 <- DBI::dbGetQuery(con,
                               "SELECT *
                               FROM log_records_3")
logrecords4 <- DBI::dbGetQuery(con,
                               "SELECT *
                               FROM log_records_4")
logrecords5 <- DBI::dbGetQuery(con,
                               "SELECT *
                               FROM log_records_5")
logrecords60 <- DBI::dbGetQuery(con,
                                "SELECT *
                               FROM log_records_60")
```

#### Getting items in all domains that are filled out by the maximum number of users
```{r}
# Function to find all item IDs filled out by the maximum number of users
# in a list of data frames

# Lintr fix: setting some variables global
utils::globalVariables(c("new_user_id", "item_id", "count_users"))

find_all_users_item_ids <- function(data_list) {
  # Initialize an empty list to store the results for each data frame
  all_users_item_ids_list <- list()

  # Iterate through each data frame in the input list
  for (i in seq_along(data_list)) {

    # Extract distinct user-item pairs for the current data frame
    item_counts <- data_list[[i]] %>%
      distinct(new_user_id, item_id) %>%

      # Group the data by item_id and calculate the count of distinct users
      group_by(item_id) %>%
      summarize(count_users = n_distinct(new_user_id))

    # Filter the item counts to find the item(s) with the maximum count of users
    all_users_item_ids <- item_counts %>%
      filter(count_users == max(count_users)) %>%

      # Extract the item_id(s) from the filtered data
      pull(item_id)

    # Store the result in the output list for this data frame
    all_users_item_ids_list[[i]] <- all_users_item_ids
  }

  # Return the list of item IDs associated with the maximum user
  # counts for each data frame
  return(all_users_item_ids_list)
}

# Create a named list of your data frames
data_list <- list(
  logrecords1 = logrecords1,
  logrecords2 = logrecords2,
  logrecords3 = logrecords3,
  logrecords4 = logrecords4,
  logrecords5 = logrecords5,
  logrecords15 = logrecords15,
  logrecords16 = logrecords16,
  logrecords60 = logrecords60
)

# Call the function to find item IDs filled out by all users for each data frame
result <- find_all_users_item_ids(data_list)

# Output the results for each data frame with their names
for (i in seq_along(result)) {
  cat("Item IDs for logrecords", i,
      "that are filled out by the highest number of users:",
      toString(result[[i]]), "\n")
}
```

#### Creating data frames with item selection
```{r}
logrecords1_187692 <- DBI::dbGetQuery(con,
                                      "SELECT *
                                       FROM `log_records_1`
                                       WHERE `item_id` = '187692'")

logrecords2_188352 <- DBI::dbGetQuery(con,
                                      "SELECT *
                                      FROM `log_records_2`
                                      WHERE `item_id` = '188352'")
logrecords3_126352 <- DBI::dbGetQuery(con,
                                      "SELECT *
                                      FROM `log_records_3`
                                      WHERE `item_id` = '126352'")
logrecords4_126463 <- DBI::dbGetQuery(con,
                                      "SELECT *
                                      FROM `log_records_4`
                                      WHERE `item_id` = '126463'")
logrecords5_1766 <- DBI::dbGetQuery(con,
                                    "SELECT *
                                    FROM `log_records_5`
                                    WHERE `item_id` = '1766'")
logrecords15_63992 <- DBI::dbGetQuery(con,
                                      "SELECT *
                                      FROM `log_records_15`
                                      WHERE `item_id` = '63992'")
logrecords16_68672 <- DBI::dbGetQuery(con,
                                      "SELECT *
                                      FROM `log_records_16`
                                      WHERE `item_id` = '68672'")
logrecords60_210942 <- DBI::dbGetQuery(con,
                                       "SELECT *
                                       FROM `log_records_60`
                                       WHERE `item_id` = '210942'")
```

#### Merging these dataframes
```{r}
# List of dataframes
dataframes_list <- list(
  logrecords1_187692,
  logrecords2_188352,
  logrecords3_126352,
  logrecords4_126463,
  logrecords5_1766,
  logrecords15_63992,
  logrecords16_68672,
  logrecords60_210942
)

# Merge all dataframes vertically
merged_dataframe <- bind_rows(dataframes_list)
```

#### Finding the minimum length to put all item reponses in one data frame that can be handled by mirt
```{r}
# Function to count rows in a dataframe
count_rows_in_dataframe <- function(df) {
  return(nrow(df))
}

# Create an empty vector to store the row counts
row_counts <- numeric(length(dataframes_list))

# Iterate through the list of dataframes and count rows
for (i in seq_along(dataframes_list)) {
  row_counts[i] <- count_rows_in_dataframe(dataframes_list[[i]])
}

print(row_counts) # Minimum length is 520
```

#### Creating a data frame with answers
```{r}
answer_data <- cbind(logrecords1_187692$correct_answered[1:520],
                     logrecords2_188352$correct_answered[1:520],
                     logrecords3_126352$correct_answered[1:520],
                     logrecords4_126463$correct_answered[1:520],
                     logrecords5_1766$correct_answered[1:520],
                     logrecords15_63992$correct_answered[1:520],
                     logrecords16_68672$correct_answered[1:520],
                     logrecords60_210942$correct_answered[1:520]) %>%
  as.data.frame()
```

# Modelling
#### Two parameter model
```{r, results = 'hide'}
two_pl <- mirt(answer_data, 1, itemtype = "2PL")
summary(two_pl)$coef
```

#### Parameters
```{r}
# Getting item parameters
item_params <- coef(two_pl)

# Creating a dataframe out of this
pars <- rbind(item_params[[1]], item_params[[2]], item_params[[3]],
              item_params[[4]], item_params[[5]], item_params[[6]],
              item_params[[7]], item_params[[8]]) %>%
  as.data.frame()

# Changing rownames to the item ids
rownames(pars) <- c("187692", "188352", "126352", "126463", "1766",
                    "63992", "68672", "210942")

# Converting rownumbers into item_id columns
pars <- tibble::rownames_to_column(pars, "item_id")

# Only discrimination and difficulty included
pars <- pars[, 1:3]

# Changing column names
colnames(pars) <- c("item_id", "discrimination", "difficulty")

# Checking
pars
```

#### Probabilities
```{r}
n_items <- nrow(pars)  # Number of items

# Calculating the range for theta_range to include all probabilities from 0 to 1

lower_bound <- -20  # Adjusting based on your expected mid-point
# --> -20 based on our exploratory analysis of four items

upper_bound <- 20  # Adjusting based on expected mid-point

# Checking if plogis(upper_bound) and plogis(lower_bound) are close to 1 and 0
if (plogis(upper_bound) < 0.999 && plogis(lower_bound) > 0.001) {

  # If not, expand the range
  while (plogis(upper_bound) < 0.999) {
    upper_bound <- upper_bound + 1
  }
  while (plogis(lower_bound) > 0.001) {
    lower_bound <- lower_bound - 1
  }
}

# Defining theta_range with the calculated range
n_values <- 100  # Number of values in theta_range
theta_range <- seq(lower_bound, upper_bound, length.out = n_values)


# Initializing an empty matrix to store results
probs <- matrix(NA, nrow = n_values, ncol = n_items)

# Looping through items and apply the transformation
for (i in 1:n_items) {
  probs[, i] <- plogis(pars[i, 2] * (theta_range - pars[i, 3]))
}

# Adding theta values as column
probs <- cbind(theta_range, probs) %>% as.data.frame

# Chaning column names
colnames(probs) <- c("theta", "187692", "188352", "126352",
                     "126463", "1766", "63992", "68672", "210942")

# Checking
probs %>% head(10)

# All seem to be nicely in a range from 0 to 1

## Ability levels where prob correct = 0.5 for selected 4 items

# item 210942
point_210942 <- theta_range[which.min(abs(probs[, 9] - 0.5))]

# item 126352
point_126352 <- theta_range[which.min(abs(probs[, 4] - 0.5))]

# item 63992
point_63992 <- theta_range[which.min(abs(probs[, 7] - 0.5))]

# item 68672
point_68672 <- theta_range[which.min(abs(probs[, 8] - 0.5))]

print(point_210942)
print(point_126352)
print(point_63992)
print(point_68672)
```

# Plotting EXAMPLE
```{r}
## PLOT ICC (just as example)

# create a data frame for the probabilities of first item
icc_data_1 <- data.frame(Theta = probs[, 1],
                         ProbCorrect = probs[, 2])
# first two columns for theta values and probs of first item

# find out at what ability/theta level the probability of correct is 0.5
theta_range[which.min(abs(probs[, 2] - 0.5))] # 1.82

# plot the ICC
plot_icc_1 <- icc_data_1 %>%
  ggplot(aes(x = Theta, y = ProbCorrect)) +
  # theta on x axis, P(correct) of item 187692 on y axis

  geom_line(color = "#000000") + # add black curve
  # add vertical blue line at theta level where P(correct) is 0.5:
  geom_vline(xintercept = 0.8, linetype = "dashed", color = "#1f77b4") +
  # add labels:
  labs(x = "Ability", y = "Probability of Correct",
       title = "Item 290") +
  # annotate line
  annotate("text", x = 1, y = 0.4, size = 2.5, label =
             "Ability level (1.63) at which \n probability of correct is 0.5",
           colour = "#1f77b4") +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme_minimal()
# probably adjust theta range

# check
plot_icc_1
# seems good

## FREQUENCY PLOT OF DISCRIMINATIONS (just a basic plot as example)

pars %>%
  ggplot(aes(x = reorder(factor(item_id), discrimination),
             y = discrimination)) +
  geom_bar(stat = "identity") +
  coord_flip()

# can do the same for difficulty if we would want that
pars %>%
  ggplot(aes(x = reorder(factor(item_id), difficulty),
             y = difficulty)) +
  geom_bar(stat = "identity") +
  coord_flip()
```

# Descriptives
#### Total number of unique users of the 8 selected items
```{r}
# Defining such a dataframe list
dataframes_list_s <- list(
  Addition_187692 = logrecords1_187692,
  Subtraction_188352 = logrecords2_188352,
  Multiplication_126352 = logrecords3_126352,
  Division_126463 = logrecords4_126463,
  Mix_1766 = logrecords5_1766,
  Flash_63992 = logrecords15_63992,
  Dictation_68672 = logrecords16_68672,
  Stories_210942 = logrecords60_210942
)

unique_user_counts_selected <- list()

# Loop through the dataframes and calculate the number of unique users
for (df_name_selected in names(dataframes_list_s)) {
  unique_users_selected <-
    length(unique(dataframes_list_s[[df_name_selected]]$new_user_id))
  unique_user_counts_selected[[df_name_selected]] <- unique_users_selected
}

overall_unique_user_count <- sum(unlist(unique_user_counts_selected))
cat(paste("The overall number of unique users in the 8 domains top items:",
          overall_unique_user_count, "\n"))
```

#### Count of all item operations of the selected 8 items
```{r}
## Item operations full
# Create a function to find the number of unique values in the 'id' column
count_unique_ids <- function(df) {
  return(length(unique(df$id)))
}

## Item operations selected
# Apply the function to each dataframe in the list
unique_id_counts_selected <- sapply(dataframes_list_s, count_unique_ids)

## Overall operations per selected vs. original
# Creating dataframes of the resulting outputs
result_df_selected <- data.frame(Dataframe = names(unique_id_counts_selected),
                                 Unique_ID_Count = unique_id_counts_selected)

# Sum the count columns to get the total counts
total_unique_id_count_selected <- sum(result_df_selected$Unique_ID_Count)

# Print the total count
cat("Total Operation Count in the Selected Data:",
    total_unique_id_count_selected)
```

#### Average difficulty of selected 8 items
```{r}
# Create average difficulty variable
average_difficulty <- round(mean(pars$difficulty, na.rm = TRUE), 3)

# Print the result
cat("The average difficulty of selected items is:", average_difficulty, "\n")
```

#### Average discrimination of selected 8 items
```{r}
# Create average discrimination variable
average_discrimination <- round(mean(pars$discrimination, na.rm = TRUE), 3)

# Print the result
cat("The average discrimination of selected items is:",
    average_discrimination, "\n")
```
#### Total number of items in all 8 domains
```{r}
# Initial dataframes list
initial_dataframes_list <- list(
  Addition = logrecords1,
  Subtraction = logrecords2,
  Multiplication = logrecords3,
  Division = logrecords4,
  Mix = logrecords5,
  Flash = logrecords15,
  Dictation = logrecords16,
  Stories = logrecords60
)

## Count of items
# Create an empty vector to store the counts for each data frame
item_counts_per_dataframe <- vector("integer", length(initial_dataframes_list))

# Iterate through the list of data frames, count unique item IDs,
# and display results
for (i in seq_along(initial_dataframes_list)) {
  # Extract the name of the current data frame
  df_name <- names(initial_dataframes_list)[i]

  item_counts_per_dataframe[i] <- length(unique(initial_dataframes_list[[i]]$
                                                  item_id))
}

total_item_count <- sum(item_counts_per_dataframe)
cat("Total number of items in all 8 domains combined:", total_item_count, "\n")
```

#### Combining descriptives into a single dataframe
```{r}
descr <- data.frame(
  "Overall Number of Unique Users" = overall_unique_user_count,
  "Total Operation Count in the Selected Data" = total_unique_id_count_selected,
  "Average Difficulty of Selected Items" = average_difficulty,
  "Average Discrimination of Selected Items" = average_discrimination,
  "Total Number of Items in All 8 Domains Combined" = total_item_count
)

descr <- data.frame(
  Variable = names(descr),
  Value = as.numeric(descr),
  stringsAsFactors = FALSE
)

print(descr)
```

# Creating files for tableau
```{r}
# parameters
file_path <- "~/BDST_DV_ASS_3_FINAL/parameters.csv"

# Write the data frame to the CSV file
write.csv(pars, file = file_path, row.names = FALSE)

# probabilities
file_path_2 <- "~/BDST_DV_ASS_3_FINAL/probabilities.csv"

# Write the data frame to the CSV file
write.csv(probs, file = file_path_2, row.names = FALSE)

# descriptives
file_path_3 <- "~/BDST_DV_ASS_3_FINAL/descriptives.csv"

# Write the data frame to the CSV file
write.csv(descr, file = file_path_3, row.names = FALSE)
```

